Source: https://developer.apple.com/documentation/SwiftUI/Controlling-the-timing-and-movements-of-your-animations

[ Skip Navigation ](https://developer.apple.com/documentation/SwiftUI/Controlling-the-timing-and-movements-of-your-animations#app-main)
  * [Global Nav Open Menu](https://developer.apple.com/documentation/SwiftUI/Controlling-the-timing-and-movements-of-your-animations#ac-gn-menustate)[Global Nav Close Menu](https://developer.apple.com/documentation/SwiftUI/Controlling-the-timing-and-movements-of-your-animations)
  * [Apple Developer](https://developer.apple.com/)


[ Search Developer Cancel  ](https://developer.apple.com/search/)
  * [Apple Developer](https://developer.apple.com/)
  * [News](https://developer.apple.com/news/)
  * [Discover](https://developer.apple.com/discover/)
  * [Design](https://developer.apple.com/design/)
  * [Develop](https://developer.apple.com/develop/)
  * [Distribute](https://developer.apple.com/distribute/)
  * [Support](https://developer.apple.com/support/)
  * [Account](https://developer.apple.com/account/)
  * [](https://developer.apple.com/search/)


Cancel 
Only search within “Documentation”
### Quick Links
  * [Downloads](https://developer.apple.com/download/)
  * [Documentation](https://developer.apple.com/documentation/)
  * [Sample Code](https://developer.apple.com/documentation/samplecode/)
  * [Videos](https://developer.apple.com/videos/)
  * [Forums](https://developer.apple.com/forums/)

5 Quick Links
[ Documentation ](https://developer.apple.com/documentation)
[ Open Menu ](https://developer.apple.com/documentation/SwiftUI/Controlling-the-timing-and-movements-of-your-animations)
  * SwiftLanguage: Swift


[](https://developer.apple.com/documentation/SwiftUI/Controlling-the-timing-and-movements-of-your-animations)
## [ SwiftUI  ](https://developer.apple.com/documentation/swiftui)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
1 of 63 symbols inside <root>
Essentials
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
2 of 63 symbols inside <root> [Adopting Liquid Glass](https://developer.apple.com/documentation/technologyoverviews/adopting-liquid-glass)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
3 of 63 symbols inside <root> [Learning SwiftUI](https://developer.apple.com/tutorials/swiftui-concepts)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
4 of 63 symbols inside <root> [Exploring SwiftUI Sample Apps](https://developer.apple.com/tutorials/sample-apps)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
5 of 63 symbols inside <root> [SwiftUI updates](https://developer.apple.com/documentation/updates/swiftui)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
6 of 63 symbols inside <root> containing 5 symbols[Landmarks: Building an app with Liquid Glass](https://developer.apple.com/documentation/swiftui/landmarks-building-an-app-with-liquid-glass)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
7 of 63 symbols inside <root>
App structure
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
Collection
8 of 63 symbols inside <root> containing 21 symbols[App organization](https://developer.apple.com/documentation/swiftui/app-organization)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
Collection
9 of 63 symbols inside <root> containing 19 symbols[Scenes](https://developer.apple.com/documentation/swiftui/scenes)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
Collection
10 of 63 symbols inside <root> containing 82 symbols[Windows](https://developer.apple.com/documentation/swiftui/windows)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
Collection
11 of 63 symbols inside <root> containing 28 symbols[Immersive spaces](https://developer.apple.com/documentation/swiftui/immersive-spaces)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
Collection
12 of 63 symbols inside <root> containing 34 symbols[Documents](https://developer.apple.com/documentation/swiftui/documents)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
Collection
13 of 63 symbols inside <root> containing 65 symbols[Navigation](https://developer.apple.com/documentation/swiftui/navigation)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
Collection
14 of 63 symbols inside <root> containing 95 symbols[Modal presentations](https://developer.apple.com/documentation/swiftui/modal-presentations)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
Collection
15 of 63 symbols inside <root> containing 45 symbols[Toolbars](https://developer.apple.com/documentation/swiftui/toolbars)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
Collection
16 of 63 symbols inside <root> containing 36 symbols[Search](https://developer.apple.com/documentation/swiftui/search)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
Collection
17 of 63 symbols inside <root> containing 29 symbols[App extensions](https://developer.apple.com/documentation/swiftui/app-extensions)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
18 of 63 symbols inside <root>
Data and storage
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
3 of 81 symbols inside 759532354 [func withAnimation<Result>(Animation?, completionCriteria: AnimationCompletionCriteria, () throws -> Result, completion: () -> Void) rethrows -> Result](https://developer.apple.com/documentation/swiftui/withanimation\(_:completioncriteria:_:completion:\))
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
S
4 of 81 symbols inside 759532354 containing 3 symbols[AnimationCompletionCriteria](https://developer.apple.com/documentation/swiftui/animationcompletioncriteria)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
S
4 of 81 symbols inside 759532354 containing 3 symbols[AnimationCompletionCriteria](https://developer.apple.com/documentation/swiftui/animationcompletioncriteria)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
S
5 of 81 symbols inside 759532354 containing 53 symbols[Animation](https://developer.apple.com/documentation/swiftui/animation)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
6 of 81 symbols inside 759532354 
Adding state-based animation to a view
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
M
7 of 81 symbols inside 759532354 [func animation(_:)](https://developer.apple.com/documentation/swiftui/view/animation\(_:\))
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
M
8 of 81 symbols inside 759532354 [func animation<V>(Animation?, value: V) -> some View](https://developer.apple.com/documentation/swiftui/view/animation\(_:value:\))
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
M
9 of 81 symbols inside 759532354 [func animation<V>(Animation?, body: (PlaceholderContentView<Self>) -> V) -> some View](https://developer.apple.com/documentation/swiftui/view/animation\(_:body:\))
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
10 of 81 symbols inside 759532354 
Creating phase-based animation
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
11 of 81 symbols inside 759532354 [Controlling the timing and movements of your animations](https://developer.apple.com/documentation/swiftui/controlling-the-timing-and-movements-of-your-animations)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
M
12 of 81 symbols inside 759532354 [func phaseAnimator<Phase>(some Sequence, content: (PlaceholderContentView<Self>, Phase) -> some View, animation: (Phase) -> Animation?) -> some View](https://developer.apple.com/documentation/swiftui/view/phaseanimator\(_:content:animation:\))
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
M
13 of 81 symbols inside 759532354 [func phaseAnimator<Phase>(some Sequence, trigger: some Equatable, content: (PlaceholderContentView<Self>, Phase) -> some View, animation: (Phase) -> Animation?) -> some View](https://developer.apple.com/documentation/swiftui/view/phaseanimator\(_:trigger:content:animation:\))
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
S
14 of 81 symbols inside 759532354 containing 3 symbols[PhaseAnimator](https://developer.apple.com/documentation/swiftui/phaseanimator)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
15 of 81 symbols inside 759532354 
Creating keyframe-based animation
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
M
16 of 81 symbols inside 759532354 [func keyframeAnimator<Value>(initialValue: Value, repeating: Bool, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View](https://developer.apple.com/documentation/swiftui/view/keyframeanimator\(initialvalue:repeating:content:keyframes:\))
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
M
17 of 81 symbols inside 759532354 [func keyframeAnimator<Value>(initialValue: Value, trigger: some Equatable, content: (PlaceholderContentView<Self>, Value) -> some View, keyframes: (Value) -> some Keyframes) -> some View](https://developer.apple.com/documentation/swiftui/view/keyframeanimator\(initialvalue:trigger:content:keyframes:\))
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
S
18 of 81 symbols inside 759532354 containing 3 symbols[KeyframeAnimator](https://developer.apple.com/documentation/swiftui/keyframeanimator)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
rP
19 of 81 symbols inside 759532354 containing 4 symbols[Keyframes](https://developer.apple.com/documentation/swiftui/keyframes)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
S
20 of 81 symbols inside 759532354 containing 7 symbols[KeyframeTimeline](https://developer.apple.com/documentation/swiftui/keyframetimeline)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
S
21 of 81 symbols inside 759532354 containing 3 symbols[KeyframeTrack](https://developer.apple.com/documentation/swiftui/keyframetrack)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
S
22 of 81 symbols inside 759532354 containing 9 symbols[KeyframeTrackContentBuilder](https://developer.apple.com/documentation/swiftui/keyframetrackcontentbuilder)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
S
23 of 81 symbols inside 759532354 containing 9 symbols[KeyframesBuilder](https://developer.apple.com/documentation/swiftui/keyframesbuilder)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
rP
24 of 81 symbols inside 759532354 containing 4 symbols[KeyframeTrackContent](https://developer.apple.com/documentation/swiftui/keyframetrackcontent)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
S
25 of 81 symbols inside 759532354 containing 2 symbols[CubicKeyframe](https://developer.apple.com/documentation/swiftui/cubickeyframe)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
S
26 of 81 symbols inside 759532354 containing 2 symbols[LinearKeyframe](https://developer.apple.com/documentation/swiftui/linearkeyframe)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
S
27 of 81 symbols inside 759532354 containing 2 symbols[MoveKeyframe](https://developer.apple.com/documentation/swiftui/movekeyframe)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
S
28 of 81 symbols inside 759532354 containing 2 symbols[SpringKeyframe](https://developer.apple.com/documentation/swiftui/springkeyframe)
144 items were found. Tab back to navigate through them. 
/ 
Navigator is ready 
  * [ SwiftUI ](https://developer.apple.com/documentation/swiftui)
  * [ Animations ](https://developer.apple.com/documentation/swiftui/animations)
  * [ Controlling the timing and movements of your animations ](https://developer.apple.com/documentation/SwiftUI/Controlling-the-timing-and-movements-of-your-animations)
  *     * [ Animations ](https://developer.apple.com/documentation/swiftui/animations)
    * Controlling the timing and movements of your animations 


Sample Code
# Controlling the timing and movements of your animations
Build sophisticated animations that you control using phase and keyframe animators.
[ Download ](https://docs-assets.developer.apple.com/published/354a9f65c3b5/PhaseAndKeyframeAnimationSample.zip)
iOS 17.0+iPadOS 17.0+macOS 14.0+Xcode 15.0+
## [Overview](https://developer.apple.com/documentation/SwiftUI/Controlling-the-timing-and-movements-of-your-animations#Overview)
SwiftUI provides a collection of useful animations that you can use in your app. These animations help enhance the user experience of your app by providing visual transitions of views and user interface elements. While these standard animations provide a great way to enhancement the user interaction of your app, there are times when you need to have more control over the timing and movement of a visual element. [`PhaseAnimator`](https://developer.apple.com/documentation/swiftui/phaseanimator) and [`KeyframeAnimator`](https://developer.apple.com/documentation/swiftui/keyframeanimator) help give you that control.
A phase animator allows you to define an animation as a collection of discrete steps called phases. The animator cycles through these phases to create a visual transition. With keyframe animator, you create keyframes that define animation values at specific times during the visual transition.
## [Create a simple bounce animation](https://developer.apple.com/documentation/SwiftUI/Controlling-the-timing-and-movements-of-your-animations#Create-a-simple-bounce-animation)
To better understand how to create animations using a [`PhaseAnimator`](https://developer.apple.com/documentation/swiftui/phaseanimator) or [`KeyframeAnimator`](https://developer.apple.com/documentation/swiftui/keyframeanimator), start with a simple example that uses standard SwiftUI animations. The following code moves an emoji upwards by setting its offset to `-40.0`. To provide a smooth transition of the movement, the code uses the [`withAnimation(_:_:)`](https://developer.apple.com/documentation/swiftui/withanimation\(_:_:\)) function to apply a [`bouncy`](https://developer.apple.com/documentation/swiftui/animation/bouncy) animation after someone taps the emoji.
```
struct SimpleAnimationView: View {
    var emoji: String
    @State private var offset = 0.0


    var body: some View {
        EmojiView(emoji: emoji)
            .offset(y: offset)
            .onTapGesture {
                withAnimation(.bouncy) {
                    offset = -40.0
                }
            }
    }
}

```

This animation has a single, discrete step: move the emoji upward. However, an animation can have multiple steps, such as moving an emoji upwards then back to its original position. For example, the following code sets the offset to `-40.0` to move the emoji upward, and then sets the offset (`0.0`) to return the emoji back to its original position:
```
struct SimpleAnimationView: View {
    var emoji: String
    @State private var offset = 0.0


    var body: some View {
        EmojiView(emoji: emoji)
            .offset(y: offset)
            .onTapGesture {
                withAnimation(.bouncy) {
                    offset = -40.0
                } completion: {
                    withAnimation {
                        offset = 0.0
                    }
                }
            }
    }
}

```

This code uses the [`withAnimation(_:completionCriteria:_:completion:)`](https://developer.apple.com/documentation/swiftui/withanimation\(_:completioncriteria:_:completion:\)) function to animate the two steps of the visual transition. The first step occurs in the `body` closure of the function, setting the offset to `-40.0`. The second step occurs in the `completion` closure, setting the offset to `0.0`.
Video with custom controls. 
Content description: A video that shows a heart-shaped emoji that moves up to its peak position, then returns to its original position. 
[ Play ](https://developer.apple.com/documentation/SwiftUI/Controlling-the-timing-and-movements-of-your-animations)
However, `EmojiView` actually goes through three steps. The first step happens when the view appears for the first time. The offset of the `EmojiView` view is `0.0`. When someone taps the view, the offset changes to `-40.0`; this is the second step. When that animation completes, the third step changes the offset back to `0.0`. However, there are only two discrete steps, based on the offset values (`0.0` and `-40.0`).
While this implementation certainly works as expected, using a [`PhaseAnimator`](https://developer.apple.com/documentation/swiftui/phaseanimator) is a more convenient way to define discrete steps as phases of an animation.
## [Bounce with a phase animator](https://developer.apple.com/documentation/SwiftUI/Controlling-the-timing-and-movements-of-your-animations#Bounce-with-a-phase-animator)
A [`PhaseAnimator`](https://developer.apple.com/documentation/swiftui/phaseanimator) automatically advances through a set of given phases to create an animated transition. Use the [`phaseAnimator(_:content:animation:)`](https://developer.apple.com/documentation/swiftui/view/phaseanimator\(_:content:animation:\)) modifier to provide the animator the phases for changing the animation value. For example, the emoji bounce animation shown earlier has two phases: move up and move back. You can represent these phases using the Boolean values, `true` and `false`. When the phase is `true`, the emoji moves up to `-40.0`. When the phase is `false`, the emoji moves back to the original position by setting the offset to `0.0`.
```
struct TwoPhaseAnimationView: View {
    var emoji: String
    
    var body: some View {
        EmojiView(emoji: emoji)
            .phaseAnimator([false, true]) { content, phase in
                content.offset(y: phase ? -40.0 : 0.0)
            }
    }
}

```

The phase animator cycles through the list of phases in the order that you provide to the [`phaseAnimator(_:content:animation:)`](https://developer.apple.com/documentation/swiftui/view/phaseanimator\(_:content:animation:\)) modifier. When the view first appears, the phase animator invokes the `content` closure passing in the first phase. Then the animator calls the closure with the value of the second phase. The animator continues to call the `content` closure for each additional phase. After reaching the last phase, the animator calls `content` one more time with the value of the first phase.
This means that in the previous code, the phase animator calls `content` with the phase value of `false` when the view first appears. This sets the emoji’s offset to `0.0`. The phase animator then calls `content` with the `true` phase. This phase sets the offset to `-40.0`, causing the emoji to move upwards. After reaching that offset position, the animator calls `content` with the phase of `false`. This causes the emoji to move back to its original position by setting its offset to `0.0`.
This animation starts when the view appears. To start the animation based on an event, use the [`phaseAnimator(_:trigger:content:animation:)`](https://developer.apple.com/documentation/swiftui/view/phaseanimator\(_:trigger:content:animation:\)) modifier and provide a `trigger` value that animator observes for changes. The animator starts the animation when the value changes. For example, the following code increments the state variable `likeCount` each time a person taps the emoji. The code uses `likeCount` as the value that the phase animator observes for changes. Now whenever someone taps the emoji, it moves up and returns to its original position.
```
struct TwoPhaseAnimationView: View {
    var emoji: String
    @State private var likeCount = 1
    
    var body: some View {
        EmojiView(emoji: emoji)
            .phaseAnimator([false, true], trigger: likeCount) { content, phase in
                content.offset(y: phase ? -40.0 : 0.0)
            }
            .onTapGesture {
                likeCount += 1
            }
    }
}

```

Video with custom controls. 
Content description: A video that shows a heart-shaped emoji that moves up to its peak position, then returns to its original position. 
[ Play ](https://developer.apple.com/documentation/SwiftUI/Controlling-the-timing-and-movements-of-your-animations)
So far, the phase animator uses the [`default`](https://developer.apple.com/documentation/swiftui/animation/default) animation to move the emoji. You can change that behavior by providing the `phaseAnimator` modifier an animation closure. In this closure, specify the type of animation to apply for each phase. For instance, the following code applies a [`bouncy`](https://developer.apple.com/documentation/swiftui/animation/bouncy) animation when the phase is `true`; otherwise, it applies the [`default`](https://developer.apple.com/documentation/swiftui/animation/default) animation:
```
struct TwoPhaseAnimationView: View {
    var emoji: String
    @State private var likeCount = 1
    
    var body: some View {
        EmojiView(emoji: emoji)
            .phaseAnimator([false, true], trigger: likeCount) { content, phase in
                content.offset(y: phase ? -40.0 : 0.0)
            } animation: { phase in
                phase ? .bouncy : .default
            }
            .onTapGesture {
                likeCount += 1
            }
    }
}

```

Video with custom controls. 
Content description: A video that shows a heart-shaped emoji that bounces slightly downward before moving up. After the emoji reaches its peak position, it moves downward, returning to its original position. 
[ Play ](https://developer.apple.com/documentation/SwiftUI/Controlling-the-timing-and-movements-of-your-animations)
## [Add more phases to the animation](https://developer.apple.com/documentation/SwiftUI/Controlling-the-timing-and-movements-of-your-animations#Add-more-phases-to-the-animation)
While this bounce effect is nice, you can add more pizzazz to it. For instance, you could make the emoji increase in size as it moves upward, and then shrink back to normal size. To do this, you’ll add a third phase to the animation: scale.
To define the phases, create a custom type that lists the possible phases; for example:
```
private enum AnimationPhase: CaseIterable {
    case initial
    case move
    case scale
}

```

Next, to help simplify logic and reduce complexity, define computed properties that return the values to animate. For instance, to set the vertical offset to move the emoji, create a computed property that returns the offset based on the current phase:
```
private enum AnimationPhase: CaseIterable {
    case initial
    case move
    case scale
    
    var verticalOffset: Double {
        switch self {
        case .initial: 0
        case .move, .scale: -64
        }
    }
}

```

When at the initial phase, the offset is `0`, which is the original screen location for the emoji. But when the phase is `move` or `scale`, the offset is `-64`.
You can use the same approach (creating a computed property) for the scale effect to change the size of the emoji. Initially, the emoji appears at its original size, but increases in size during the move and scale phase, as shown here:
```
private enum AnimationPhase: CaseIterable {
    case initial
    case move
    case scale
    
    var verticalOffset: Double {
        switch self {
        case .initial: 0
        case .move, .scale: -64
        }
    }
    
    var scaleEffect: Double {
        switch self {
        case .initial: 1
        case .move, .scale: 1.5
        }
    }
}

```

To animate an emoji, apply the [`phaseAnimator(_:trigger:content:animation:)`](https://developer.apple.com/documentation/swiftui/view/phaseanimator\(_:trigger:content:animation:\)) modifier to the `EmojiView`. Provide the animator all cases from the custom `AnimationPhase` type. Then change the content based on the phase by applying the [`scaleEffect(_:anchor:)`](https://developer.apple.com/documentation/swiftui/view/scaleeffect\(_:anchor:\)) and [`offset(x:y:)`](https://developer.apple.com/documentation/swiftui/view/offset\(x:y:\)) modifiers. The values passed into these modifiers come from the computed properties, which helps keep the view code more readable.
```
struct ThreePhaseAnimationView: View {
    var emoji: String
    @State private var likeCount = 1
    
    var body: some View {
        EmojiView(emoji: emoji)
            .phaseAnimator(AnimationPhase.allCases, trigger: likeCount) { content, phase in
                content
                    .scaleEffect(phase.scaleEffect)
                    .offset(y: phase.verticalOffset)
            } animation: { phase in
                switch phase {
                case .initial: .smooth
                case .move: .easeInOut(duration: 0.3)
                case .scale: .spring(duration: 0.3, bounce: 0.7)
                }
            }
            .onTapGesture {
                likeCount += 1
            }
    }
}

```

The code also applies different animation types based on the phase in the `animation` closure to give the full animation that pizzazz you were looking for.
Video with custom controls. 
Content description: A video that shows a heart-shaped emoji that moves up. As the emoji moves upwards, it grows larger in size. When the emoji reaches its peak position, it moves back down to its original position while returning to its original size. 
[ Play ](https://developer.apple.com/documentation/SwiftUI/Controlling-the-timing-and-movements-of-your-animations)
Note
Use the canvas preview in Xcode to help determine the animation types and values to apply for the phase animations. Make changes to the code and see those changes reflected in the canvas preview.
A [`PhaseAnimator`](https://developer.apple.com/documentation/swiftui/phaseanimator) gives you control of an animation based on discrete phases, which helps you add extra polish to an animation. But if you find that you need even more control over the timing and movement of an animation, use a [`KeyframeAnimator`](https://developer.apple.com/documentation/swiftui/keyframeanimator).
## [Gain more control with a keyframe animator](https://developer.apple.com/documentation/SwiftUI/Controlling-the-timing-and-movements-of-your-animations#Gain-more-control-with-a-keyframe-animator)
You can define complex, coordinated animations with complete control over timing and movement using a [`KeyframeAnimator`](https://developer.apple.com/documentation/swiftui/keyframeanimator). This animator allows you to create keyframes that define values at specific times during an animation. The animator use these values to generate interpolated values in between each frame of the animation.
Unlike a phase animator, in which you model separate, discrete states, a keyframe animator generates interpolated values of the type that you specify. While an animation is in progress, the animator provides you with a value of this type on every frame so you can update the animating view by applying modifiers to it.
You define the type as a structure that contains the properties that you want to independently animate. For example, the following code defines four properties that determine the scale, stretch, position, and angle of an emoji:
```
private struct AnimationValues {
    var scale = 1.0
    var verticalStretch = 1.0
    var verticalOffset = 0.0
    var angle = Angle.zero
}

```

Note
[`KeyframeAnimator`](https://developer.apple.com/documentation/swiftui/keyframeanimator) can animate any value that conforms to the [`Animatable`](https://developer.apple.com/documentation/swiftui/animatable) protocol.
To create a animation using a keyframe animator, apply either the [`keyframeAnimator(initialValue:repeating:content:keyframes:)`](https://developer.apple.com/documentation/swiftui/view/keyframeanimator\(initialvalue:repeating:content:keyframes:\)) or [`keyframeAnimator(initialValue:trigger:content:keyframes:)`](https://developer.apple.com/documentation/swiftui/view/keyframeanimator\(initialvalue:trigger:content:keyframes:\)) modifier to the view that you want to animate. For instance, the following code applies the second modifier to `EmojiView`. The initial value for the animation is a new instance of `AnimationValues`, and the state variable `likeCount` is the value that the animator observes for changes as it did in the previous phase animation example.
```
struct KeyframeAnimationView: View {
    var emoji: String
    @State private var likeCount = 1
    
    var body: some View {
        EmojiView(emoji: emoji)
            .keyframeAnimator(
                initialValue: AnimationValues(),
                trigger: likeCount
            ) { content, value in
                // ...
            } keyframes: { _ in
                // ...
            }
            .onTapGesture {
                likeCount += 1
            }
    }
}

```

To apply modifiers to a view during the animation, provide a `content` closure to the keyframe animator. This closure includes two parameters: 

`content`
    
The view that’s animating. 

`value`
    
The current interpolated values.
Use these parameters to apply modifiers to the view that SwiftUI is animating. For example, the following code uses these parameters to rotate, scale, stretch, and move an emoji:
```
struct KeyframeAnimationView: View {
    var emoji: String
    @State private var likeCount = 1
    
    var body: some View {
        EmojiView(emoji: emoji)
            .keyframeAnimator(
                initialValue: AnimationValues(),
                trigger: likeCount
            ) { content, value in
                content
                    .rotationEffect(value.angle)
                    .scaleEffect(value.scale)
                    .scaleEffect(y: value.verticalStretch)
                    .offset(y: value.verticalOffset)
            } keyframes: { _ in
                // ...
            }
            .onTapGesture {
                likeCount += 1
            }
    }
}

```

Important
SwiftUI calls the keyframe animator’s `content` closure on every frame of the animation, so avoid performing any expensive operations directly within it.
Next, define the keyframes. Keyframes let you build sophisticated animations with different keyframe for different properties. To make this possible, you organize the keyframes into tracks. Each track controls a different property of the type that you are animating. You associate a property to a track by providing the key path to the property when creating the track. For example, the following code adds a [`KeyframeTrack`](https://developer.apple.com/documentation/swiftui/keyframetrack) for the `scale` property:
```
struct KeyframeAnimationView: View {
    var emoji: String
    @State private var likeCount = 1
    
    var body: some View {
        EmojiView(emoji: emoji)
            .keyframeAnimator(
                initialValue: AnimationValues(),
                trigger: likeCount
            ) { content, value in
                content
                    .rotationEffect(value.angle)
                    .scaleEffect(value.scale)
                    .scaleEffect(y: value.verticalStretch)
                    .offset(y: value.verticalOffset)
            } keyframes: { _ in
                KeyframeTrack(\.scale) {
                    // ...
                }
            }
            .onTapGesture {
                likeCount += 1
            }
    }
}

```

When creating a track, you use the declarative syntax in SwiftUI to add keyframes to the track. There are different kinds of keyframes, such as [`CubicKeyframe`](https://developer.apple.com/documentation/swiftui/cubickeyframe), [`LinearKeyframe`](https://developer.apple.com/documentation/swiftui/linearkeyframe), and [`SpringKeyframe`](https://developer.apple.com/documentation/swiftui/springkeyframe). You can mix and match the different kinds of keyframes within a track. For example, the following code adds a track for the `scale` property that performs a combination of linear and spring animations:
```
struct KeyframeAnimationView: View {
    var emoji: String
    @State private var likeCount = 1
    
    var body: some View {
        EmojiView(emoji: emoji)
            .keyframeAnimator(
                initialValue: AnimationValues(),
                trigger: likeCount
            ) { content, value in
                content
                    .rotationEffect(value.angle)
                    .scaleEffect(value.scale)
                    .scaleEffect(y: value.verticalStretch)
                    .offset(y: value.verticalOffset)
            } keyframes: { _ in
                KeyframeTrack(\.scale) {
                    LinearKeyframe(1.0, duration: 0.36)
                    SpringKeyframe(1.5, duration: 0.8,
                        spring: .bouncy)
                    SpringKeyframe(1.0, spring: .bouncy)
                }
            }
            .onTapGesture {
                likeCount += 1
            }
    }
}

```

Each keyframe type receives a value. The animator uses this value to generate interpolated values between frames and sets the property specified in the track’s key path before calling the animator’s content closure. For instance, in the previous code listing, the scale value is `1.0` during the linear keyframes, which keeps the emoji at its original size. Then the scale changes to `1.5` during the first spring keyframe. This causes the emoji to grow in size. The final spring keyframe sets the scale to `1.0`, which returns the emoji back to its original size.
Note
SwiftUI preserves the velocity (that is, the speed of the animation) across multiple keyframes for continuous motion within a track.
When implementing a keyframe animation, include a track for each property that you want to animate. For instance, `AnimationValues` has four properties:
  * `scale`
  * `verticalStretch`
  * `verticalOffset`
  * `angle`


To animate all four, the animator needs four keyframe tracks as shown in the following code:
```
struct KeyframeAnimationView: View {
    var emoji: String
    @State private var likeCount = 1
    
    var body: some View {
        EmojiView(emoji: emoji)
            .keyframeAnimator(
                initialValue: AnimationValues(),
                trigger: likeCount
            ) { content, value in
                content
                    .rotationEffect(value.angle)
                    .scaleEffect(value.scale)
                    .scaleEffect(y: value.verticalStretch)
                    .offset(y: value.verticalOffset)
            } keyframes: { _ in
                KeyframeTrack(\.scale) {
                    LinearKeyframe(1.0, duration: 0.36)
                    SpringKeyframe(1.5, duration: 0.8, spring: .bouncy)
                    SpringKeyframe(1.0, spring: .bouncy)
                }
                
                KeyframeTrack(\.verticalOffset) {
                    LinearKeyframe(0.0, duration: 0.1)
                    SpringKeyframe(20.0, duration: 0.15, spring: .bouncy)
                    SpringKeyframe(-60.0, duration: 1.0, spring: .bouncy)
                    SpringKeyframe(0.0, spring: .bouncy)
                }


                KeyframeTrack(\.verticalStretch) {
                    CubicKeyframe(1.0, duration: 0.1)
                    CubicKeyframe(0.6, duration: 0.15)
                    CubicKeyframe(1.5, duration: 0.1)
                    CubicKeyframe(1.05, duration: 0.15)
                    CubicKeyframe(1.0, duration: 0.88)
                    CubicKeyframe(0.8, duration: 0.1)
                    CubicKeyframe(1.04, duration: 0.4)
                    CubicKeyframe(1.0, duration: 0.22)
                }


                KeyframeTrack(\.angle) {
                    CubicKeyframe(.zero, duration: 0.58)
                    CubicKeyframe(.degrees(16), duration: 0.125)
                    CubicKeyframe(.degrees(-16), duration: 0.125)
                    CubicKeyframe(.degrees(16), duration: 0.125)
                    CubicKeyframe(.zero, duration: 0.125)
                }
            }
            .onTapGesture {
                likeCount += 1
            }
    }
}

```

The combination of these keyframe tracks creates an animation that squishes and stretches the emoji, before bouncing it upwards. As the emoji moves towards its peak, it grows larger. When the emoji reaches its peak, it gives a little wiggle. Then the emoji returns to its original location with a slight bounce as it settles back into its original position.
Video with custom controls. 
Content description: A video that shows a heart-shaped emoji that squishes and stretches, then bounces upwards. As the emoji moves towards its peak position, it grows larger. When the emoji reaches its peak, it wiggles with a slight clockwise to counter clockwise rotation. The emoji then moves down towards its original position while shrinking back to its original size. Then the emoji bounces slightly as it settles back into its original position. 
[ Play ](https://developer.apple.com/documentation/SwiftUI/Controlling-the-timing-and-movements-of-your-animations)
Note
As with phase animations, use the canvas preview in Xcode to help determine the animation types and values to apply for the keyframe animations. Make changes to the code and see those changes reflected in the canvas preview.
## [See Also](https://developer.apple.com/documentation/SwiftUI/Controlling-the-timing-and-movements-of-your-animations#see-also)
### [Creating phase-based animation](https://developer.apple.com/documentation/SwiftUI/Controlling-the-timing-and-movements-of-your-animations#Creating-phase-based-animation)
[`func phaseAnimator<Phase>(some Sequence, content: (PlaceholderContentView<Self>, Phase) -> some View, animation: (Phase) -> Animation?) -> some View`](https://developer.apple.com/documentation/swiftui/view/phaseanimator\(_:content:animation:\))
Animates effects that you apply to a view over a sequence of phases that change continuously.
[`func phaseAnimator<Phase>(some Sequence, trigger: some Equatable, content: (PlaceholderContentView<Self>, Phase) -> some View, animation: (Phase) -> Animation?) -> some View`](https://developer.apple.com/documentation/swiftui/view/phaseanimator\(_:trigger:content:animation:\))
Animates effects that you apply to a view over a sequence of phases that change based on a trigger.
[`struct PhaseAnimator`](https://developer.apple.com/documentation/swiftui/phaseanimator)
A container that animates its content by automatically cycling through a collection of phases that you provide, each defining a discrete step within an animation.
Current page is Controlling the timing and movements of your animations 
[Apple](https://www.apple.com)
  1. [Developer](https://developer.apple.com/)
  2. [ Documentation ](https://developer.apple.com/documentation/)


###  Platforms 
Toggle Menu 
  * [iOS](https://developer.apple.com/ios/)
  * [iPadOS](https://developer.apple.com/ipados/)
  * [macOS](https://developer.apple.com/macos/)
  * [tvOS](https://developer.apple.com/tvos/)
  * [visionOS](https://developer.apple.com/visionos/)
  * [watchOS](https://developer.apple.com/watchos/)


###  Tools 
Toggle Menu 
  * [Swift](https://developer.apple.com/swift/)
  * [SwiftUI](https://developer.apple.com/swiftui/)
  * [Swift Playground](https://developer.apple.com/swift-playground/)
  * [TestFlight](https://developer.apple.com/testflight/)
  * [Xcode](https://developer.apple.com/xcode/)
  * [Xcode Cloud](https://developer.apple.com/xcode-cloud/)
  * [SF Symbols](https://developer.apple.com/sf-symbols/)


###  Topics & Technologies 
Toggle Menu 
  * [Accessibility](https://developer.apple.com/accessibility/)
  * [Accessories](https://developer.apple.com/accessories/)
  * [App Extension](https://developer.apple.com/app-extensions/)
  * [App Store](https://developer.apple.com/app-store/)
  * [Audio & Video](https://developer.apple.com/audio/)
  * [Augmented Reality](https://developer.apple.com/augmented-reality/)
  * [Design](https://developer.apple.com/design/)
  * [Distribution](https://developer.apple.com/distribute/)
  * [Education](https://developer.apple.com/education/)
  * [Fonts](https://developer.apple.com/fonts/)
  * [Games](https://developer.apple.com/games/)
  * [Health & Fitness](https://developer.apple.com/health-fitness/)
  * [In-App Purchase](https://developer.apple.com/in-app-purchase/)
  * [Localization](https://developer.apple.com/localization/)
  * [Maps & Location](https://developer.apple.com/maps/)
  * [Machine Learning & AI](https://developer.apple.com/machine-learning/)
  * [Open Source](https://opensource.apple.com/)
  * [Security](https://developer.apple.com/security/)
  * [Safari & Web](https://developer.apple.com/safari/)


###  Resources 
Toggle Menu 
  *   * [Documentation](https://developer.apple.com/documentation/)
  * [Tutorials](https://developer.apple.com/learn/)
  * [Downloads](https://developer.apple.com/download/)
  * [Forums](https://developer.apple.com/forums/)
  * [Videos](https://developer.apple.com/videos/)


###  Support 
Toggle Menu 
  * [Support Articles](https://developer.apple.com/support/articles/)
  * [Contact Us](https://developer.apple.com/contact/)
  * [Bug Reporting](https://developer.apple.com/bug-reporting/)
  * [System Status](https://developer.apple.com/system-status/)


###  Account 
Toggle Menu 
  * [Apple Developer](https://developer.apple.com/account/)
  * [App Store Connect](https://appstoreconnect.apple.com/)
  * [Certificates, IDs, & Profiles](https://developer.apple.com/account/ios/certificate/)
  * [Feedback Assistant](https://feedbackassistant.apple.com/)


###  Programs 
Toggle Menu 
  * [Apple Developer Program](https://developer.apple.com/programs/)
  * [Apple Developer Enterprise Program](https://developer.apple.com/programs/enterprise/)
  * [App Store Small Business Program](https://developer.apple.com/app-store/small-business-program/)
  * [MFi Program](https://mfi.apple.com/)
  * [News Partner Program](https://developer.apple.com/programs/news-partner/)
  * [Video Partner Program](https://developer.apple.com/programs/video-partner/)
  * [Security Bounty Program](https://developer.apple.com/security-bounty/)
  * [Security Research Device Program](https://developer.apple.com/programs/security-research-device/)


###  Events 
Toggle Menu 
  * [Meet with Apple](https://developer.apple.com/events/)
  * [Apple Developer Centers](https://developer.apple.com/events/developer-centers/)
  * [App Store Awards](https://developer.apple.com/app-store/app-store-awards/)
  * [Apple Design Awards](https://developer.apple.com/design/awards/)
  * [Apple Developer Academies](https://developer.apple.com/academies/)
  * [WWDC](https://developer.apple.com/wwdc/)


To submit feedback on documentation, visit [Feedback Assistant](applefeedback://new?form_identifier=developertools.fba&answers%5B%3Aarea%5D=seedADC%3Adevpubs&answers%5B%3Adoc_type_req%5D=Technology%20Documentation&answers%5B%3Adocumentation_link_req%5D=https%3A%2F%2Fdeveloper.apple.com%2Fdocumentation%2FSwiftUI%2FControlling-the-timing-and-movements-of-your-animations).
Select a color scheme preference
Light
Dark
Auto
Copyright © 2025 [Apple Inc.](https://www.apple.com) All rights reserved. 
[ Terms of Use ](https://www.apple.com/legal/internet-services/terms/site.html)[ Privacy Policy ](https://www.apple.com/legal/privacy/)[ Agreements and Guidelines ](https://developer.apple.com/support/terms/)
