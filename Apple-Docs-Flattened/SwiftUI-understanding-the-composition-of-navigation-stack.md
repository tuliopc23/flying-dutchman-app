Source: https://developer.apple.com/documentation/swiftui/understanding-the-composition-of-navigation-stack

[ Skip Navigation ](https://developer.apple.com/documentation/swiftui/understanding-the-composition-of-navigation-stack#app-main)
  * [Global Nav Open Menu](https://developer.apple.com/documentation/swiftui/understanding-the-composition-of-navigation-stack#ac-gn-menustate)[Global Nav Close Menu](https://developer.apple.com/documentation/swiftui/understanding-the-composition-of-navigation-stack)
  * [Apple Developer](https://developer.apple.com/)


[ Search Developer Cancel  ](https://developer.apple.com/search/)
  * [Apple Developer](https://developer.apple.com/)
  * [News](https://developer.apple.com/news/)
  * [Discover](https://developer.apple.com/discover/)
  * [Design](https://developer.apple.com/design/)
  * [Develop](https://developer.apple.com/develop/)
  * [Distribute](https://developer.apple.com/distribute/)
  * [Support](https://developer.apple.com/support/)
  * [Account](https://developer.apple.com/account/)
  * [](https://developer.apple.com/search/)


Cancel 
Only search within “Documentation”
### Quick Links
  * [Downloads](https://developer.apple.com/download/)
  * [Documentation](https://developer.apple.com/documentation/)
  * [Sample Code](https://developer.apple.com/documentation/samplecode/)
  * [Videos](https://developer.apple.com/videos/)
  * [Forums](https://developer.apple.com/forums/)

5 Quick Links
[ Documentation ](https://developer.apple.com/documentation)
[ Open Menu ](https://developer.apple.com/documentation/swiftui/understanding-the-composition-of-navigation-stack)
  * SwiftLanguage: Swift


[](https://developer.apple.com/documentation/swiftui/understanding-the-composition-of-navigation-stack)
## [ SwiftUI  ](https://developer.apple.com/documentation/swiftui)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
S
13 of 65 symbols inside -1158154854 containing 4 symbols[NavigationStack](https://developer.apple.com/documentation/swiftui/navigationstack)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
Collection
8 of 63 symbols inside <root> containing 21 symbols[App organization](https://developer.apple.com/documentation/swiftui/app-organization)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
Collection
9 of 63 symbols inside <root> containing 19 symbols[Scenes](https://developer.apple.com/documentation/swiftui/scenes)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
Collection
10 of 63 symbols inside <root> containing 82 symbols[Windows](https://developer.apple.com/documentation/swiftui/windows)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
Collection
11 of 63 symbols inside <root> containing 28 symbols[Immersive spaces](https://developer.apple.com/documentation/swiftui/immersive-spaces)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
Collection
12 of 63 symbols inside <root> containing 34 symbols[Documents](https://developer.apple.com/documentation/swiftui/documents)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
Collection
13 of 63 symbols inside <root> containing 65 symbols[Navigation](https://developer.apple.com/documentation/swiftui/navigation)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
1 of 65 symbols inside -1158154854 
Essentials
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
2 of 65 symbols inside -1158154854 [Understanding the navigation stack](https://developer.apple.com/documentation/swiftui/understanding-the-composition-of-navigation-stack)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
3 of 65 symbols inside -1158154854 
Presenting views in columns
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
4 of 65 symbols inside -1158154854 [Bringing robust navigation structure to your SwiftUI app](https://developer.apple.com/documentation/swiftui/bringing-robust-navigation-structure-to-your-swiftui-app)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
5 of 65 symbols inside -1158154854 [Migrating to new navigation types](https://developer.apple.com/documentation/swiftui/migrating-to-new-navigation-types)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
S
6 of 65 symbols inside -1158154854 containing 12 symbols[NavigationSplitView](https://developer.apple.com/documentation/swiftui/navigationsplitview)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
M
7 of 65 symbols inside -1158154854 [func navigationSplitViewStyle<S>(S) -> some View](https://developer.apple.com/documentation/swiftui/view/navigationsplitviewstyle\(_:\))
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
M
8 of 65 symbols inside -1158154854 [func navigationSplitViewColumnWidth(CGFloat) -> some View](https://developer.apple.com/documentation/swiftui/view/navigationsplitviewcolumnwidth\(_:\))
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
M
9 of 65 symbols inside -1158154854 [func navigationSplitViewColumnWidth(min: CGFloat?, ideal: CGFloat, max: CGFloat?) -> some View](https://developer.apple.com/documentation/swiftui/view/navigationsplitviewcolumnwidth\(min:ideal:max:\))
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
S
10 of 65 symbols inside -1158154854 containing 5 symbols[NavigationSplitViewVisibility](https://developer.apple.com/documentation/swiftui/navigationsplitviewvisibility)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
S
11 of 65 symbols inside -1158154854 containing 10 symbols[NavigationLink](https://developer.apple.com/documentation/swiftui/navigationlink)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
12 of 65 symbols inside -1158154854 
Stacking views in one column
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
S
13 of 65 symbols inside -1158154854 containing 4 symbols[NavigationStack](https://developer.apple.com/documentation/swiftui/navigationstack)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
S
14 of 65 symbols inside -1158154854 containing 11 symbols[NavigationPath](https://developer.apple.com/documentation/swiftui/navigationpath)
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
M
15 of 65 symbols inside -1158154854 [func navigationDestination<D, C>(for: D.Type, destination: (D) -> C) -> some View](https://developer.apple.com/documentation/swiftui/view/navigationdestination\(for:destination:\))
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
M
16 of 65 symbols inside -1158154854 [func navigationDestination<V>(isPresented: Binding<Bool>, destination: () -> V) -> some View](https://developer.apple.com/documentation/swiftui/view/navigationdestination\(ispresented:destination:\))
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
M
17 of 65 symbols inside -1158154854 [func navigationDestination<D, C>(item: Binding<Optional<D>>, destination: (D) -> C) -> some View](https://developer.apple.com/documentation/swiftui/view/navigationdestination\(item:destination:\))
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
18 of 65 symbols inside -1158154854 
Managing column collapse
To navigate the symbols, press Up Arrow, Down Arrow, Left Arrow or Right Arrow 
S
19 of 65 symbols inside -1158154854 containing 4 symbols[NavigationSplitViewColumn](https://developer.apple.com/documentation/swiftui/navigationsplitviewcolumn)
128 items were found. Tab back to navigate through them. 
/ 
Navigator is ready 
  * [ SwiftUI ](https://developer.apple.com/documentation/swiftui)
  * [ Navigation ](https://developer.apple.com/documentation/swiftui/navigation)
  * [ Understanding the navigation stack ](https://developer.apple.com/documentation/swiftui/understanding-the-composition-of-navigation-stack)
  *     * [ Navigation ](https://developer.apple.com/documentation/swiftui/navigation)
    * Understanding the navigation stack 


Article
# Understanding the navigation stack
Learn about the navigation stack, links, and how to manage navigation types in your app’s structure.
## [Overview](https://developer.apple.com/documentation/swiftui/understanding-the-composition-of-navigation-stack#Overview)
A [`NavigationStack`](https://developer.apple.com/documentation/swiftui/navigationstack) is a container for your app’s navigation structure. Use a navigation stack to present a stack of views over a root view.
A `NavigationStack` exposes its state to your app with the path parameter of its initializer. To create a navigation stack with a path that you can control or track views on the navigation stack, use a [`NavigationPath`](https://developer.apple.com/documentation/swiftui/navigationpath) or a [`Binding`](https://developer.apple.com/documentation/swiftui/binding) to a [`RandomAccessCollection`](https://developer.apple.com/documentation/Swift/RandomAccessCollection) and [`RangeReplaceableCollection`](https://developer.apple.com/documentation/Swift/RangeReplaceableCollection) that contains [`Hashable`](https://developer.apple.com/documentation/Swift/Hashable) elements.
A `NavigationPath` is a type-erased collection on which you can store a heterogenous list of data. For homogenous data, use an [`Array`](https://developer.apple.com/documentation/Swift/Array) instead. Because `NavigationPath` is type-erased, it can represent different types of data that correspond to a view in the navigation stack.
Tip
Avoid using model types as elements of a navigation path. Make sure the elements of navigation paths are lightweight, and don’t use them as a mode of transport for data models.
Another element of the navigation stack is the _navigation destination_ , which encapsulates the views people can navigate to within your app.
You can present destinations on a `NavigationStack` using: 

View-destination
    
Use the [`init(destination:label:)`](https://developer.apple.com/documentation/swiftui/navigationlink/init\(destination:label:\)) initializer to push a view directly onto the navigation stack. A view-destination link is fire-and-forget: SwiftUI tracks the navigation state, but from your app’s perspective, there are no stateful hooks indicating you pushed a view. 

Value–destination
    
A value-destination indicates that you are pushing a value onto the path. SwiftUI uses the value you pushed to the path to determine the corresponding view using the [`navigationDestination(for:destination:)`](https://developer.apple.com/documentation/swiftui/view/navigationdestination\(for:destination:\)) modifier. You use [`init(value:label:)`](https://developer.apple.com/documentation/swiftui/navigationlink/init\(value:label:\)) initializer to append a value onto the navigation path and [`navigationDestination(for:destination:)`](https://developer.apple.com/documentation/swiftui/view/navigationdestination\(for:destination:\)) modifier to map the data type of the path appended to a specific destination view. You can also programmatically push views onto a navigation stack using a [`navigationDestination(isPresented:destination:)`](https://developer.apple.com/documentation/swiftui/view/navigationdestination\(ispresented:destination:\)) modifier. The destination is stateful—the state is explicitly available to your app via the Boolean binding. In cases where the presentation state is better modeled by the absence or presence of a value rather than a Boolean, use [`navigationDestination(item:destination:)`](https://developer.apple.com/documentation/swiftui/view/navigationdestination\(item:destination:\)). This modifier takes a binding to a nullable data model.
Note
Value-destination and view-destination links don’t describe the visible stack directly; instead, they refer to the data added to the path.
### [Present view–destination links](https://developer.apple.com/documentation/swiftui/understanding-the-composition-of-navigation-stack#Present-view-destination-links)
You can push a view onto a `NavigationStack` using `NavigationLink(destination:label:)`. With this initializer, you specify both a label—displayed on the link itself—and a destination—displayed when someone taps the link.
Enclose a [`NavigationLink`](https://developer.apple.com/documentation/swiftui/navigationlink) in a navigation structure higher up in the view-hierarchy—an ancestor view, for example. If this condition isn’t met, the link typically appears as disabled.
Below is an example with two links inside a `NavigationStack`:
```
struct DestinationView: View {
    var body: some View {
        NavigationStack {
            NavigationLink {
                ColorDetail(color: .mint, text: "Mint")
            } label: {
                Text("Mint")
            }
            
            NavigationLink {
                ColorDetail(color: .red, text: "Red")
            } label: {
                Text("Red")
            }
        }
    }
}


struct ColorDetail: View {
    var color: Color
    var text: String


    var body: some View {
        VStack {
            Text(text)
            color
         }
    }
}

```

In this example, tapping the label titled “Mint” pushes a `ColorDetail(color: .mint, text: "Mint")` view onto the navigation stack. The navigation stack contents are the root view (the `NavigationLink` itself) at depth `0`, and `ColorDetail(color: .mint, text: "Mint")` at depth `1`.
When you use [`init(destination:label:)`](https://developer.apple.com/documentation/swiftui/navigationlink/init\(destination:label:\)), note that:
  * SwiftUI tracks the navigation state and the content of the navigation path; however, there are no stateful hooks for your app that indicate when the system pushes a view.
  * Its state can’t be restored programmatically.


Use the stateful navigation techniques described in [Manage navigation state and compose links](https://developer.apple.com/documentation/swiftui/understanding-the-composition-of-navigation-stack#Manage-navigation-state-and-compose-links) to track when a navigation link triggers, instead of [`onAppear(perform:)`](https://developer.apple.com/documentation/swiftui/view/onappear\(perform:\)) or [`task(priority:_:)`](https://developer.apple.com/documentation/swiftui/view/task\(priority:_:\)).
Use a [`navigationDestination(isPresented:destination:)`](https://developer.apple.com/documentation/swiftui/view/navigationdestination\(ispresented:destination:\)) modifier to navigate programmatically by providing a binding to a `Boolean` value. For example, you can programmatically push `ColorDetail` view onto the stack:
```
struct DestinationView: View { 
    @State private var showDetails = false
    var favoriteColor: Color
    
    NavigationStack {
        VStack {
            Circle()
                .fill(favoriteColor)
            Button("Show details") {
                showDetails = true
            }
        }
        .navigationDestination(isPresented: $showDetails) {
            ColorDetail(color: favoriteColor, text: color.description)
        }
    }
}

```

Use this approach when you want to navigate based on toggling state rather than by people’s interaction, or when your app presents a one-off destination with a different data type than the homogenous path of the navigation stack.
### [Present value-destination links](https://developer.apple.com/documentation/swiftui/understanding-the-composition-of-navigation-stack#Present-value-destination-links)
When you add data to the navigation path, SwiftUI maps the data type to a view, then pushes it onto the navigation stack when someone taps the link. To describe the view the stack displays, use the [`navigationDestination(for:destination:)`](https://developer.apple.com/documentation/swiftui/view/navigationdestination\(for:destination:\)) view modifier inside a `NavigationStack`.
The following example implements `DestinationView` as a series of navigation links:
```
NavigationStack {
    List {
        NavigationLink("Mint", value: Color.mint)
        NavigationLink("Red", value: Color.red)
    }
    .navigationDestination(for: Color.self) { color in
        ColorDetail(color: color, text: color.description)
    }
}

```

In the example above, SwiftUI uses the value type—in this case, `Color`—to determine the appropriate navigation destination. With value-based navigation, you can define a variety of possible destinations for a single stack When someone taps “Mint”, SwiftUI pushes `ColorDetail` view with a value `.mint` onto the stack.
Value-based navigation shines in scenarios with mixed destination types. You can extend your app to handle recipe-related content in addition to colors:
```
struct ValueView: View {
    private var recipes: [Recipe] = [.applePie, .chocolateCake]
    
    var body: some View {
        NavigationStack {
            List {
                NavigationLink("Mint", value: Color.mint)
                NavigationLink("Red", value: Color.red)
                ForEach(recipes) { recipe in
                    NavigationLink(recipe.description, value: recipe)
                }
            }
            .navigationDestination(for: Color.self) { color in
                ColorDetail(color: color, text: color.description)
            }
            .navigationDestination(for: Recipe.self) { recipe in
                RecipeDetailView(recipe: recipe)
            }
        }
    }
}


struct RecipeDetailView: View {
    var recipe: Recipe
    
    var body: some View {
        Text(recipe.description)
    }
}


enum Recipe: Identifiable, Hashable, Codable {
    case applePie
    case chocolateCake
    
    var id: Self { self }
    
    var description: String {
        switch self {
        case .applePie:
            return "Apple Pie"
        case .chocolateCake:
            return "Chocolate Cake"
        }
    }
}

```

In this example, the `NavigationStack` supports two destination types: `Color` for colors, and `Recipe` for recipes. SwiftUI determines the correct destination view based on the data type of the value from the navigation link.
Use [`navigationDestination(item:destination:)`](https://developer.apple.com/documentation/swiftui/view/navigationdestination\(item:destination:\)) when you need to navigate to a view based on the presence of an item. When the item binding is non-nil, SwiftUI passes the value into the destination closure and pushes the view onto the stack. For example:
```
struct ContentView: View {
    private var recipes: [Recipe] = [.applePie, .chocolateCake]
    @State private var selectedRecipe: Recipe?
    
    var body: some View {
        NavigationStack {
            List(recipes, selection: $selectedRecipe) { recipe in
                NavigationLink(recipe.description, value: recipe)
            }
            .navigationDestination(item: $selectedRecipe) { recipe in
                RecipeDetailView(recipe: recipe)
            }
        }
    }
}

```

When a person taps a recipe, `selectedRecipe` value updates and SwiftUI pushes `RecipeDetailView(recipe: recipe)` onto the navigation stack. You can pop the view off the stack by setting `selectedRecipe` back to nil.
### [Manage navigation state and compose links](https://developer.apple.com/documentation/swiftui/understanding-the-composition-of-navigation-stack#Manage-navigation-state-and-compose-links)
By default, a navigation stack manages state to keep track of the views on the stack. However, your app can share control of the state by initializing the stack with a binding to a collection of data values that you create.
Use [`init(path:root:)`](https://developer.apple.com/documentation/swiftui/navigationstack/init\(path:root:\)), which takes a binding to a `NavigationPath` argument, when you want to observe the navigation state for this stack.
The `NavigationPath` data type is a heterogeneous collection type that accepts any `Hashable` values. You can add to the path by calling [`append(_:)`](https://developer.apple.com/documentation/swiftui/navigationpath/append\(_:\)) or when people tap value-destination links such as [`init(value:label:)`](https://developer.apple.com/documentation/swiftui/navigationlink/init\(value:label:\)).
When you push a value onto the stack using [`init(_:value:)`](https://developer.apple.com/documentation/swiftui/navigationlink/init\(_:value:\)), you append the value to the path, as shown below:
```
struct ContentView: View {
    @State private var path = NavigationPath()


    var body: some View {
        NavigationStack(path: $path) {
            List {
                NavigationLink("Mint", value: Color.mint)
                NavigationLink("Red", value: Color.red)
            }
            .navigationDestination(for: Color.self) { color in
                ColorDetail(color: color)
            }
        }
    }
}

```

In this example, when someone activates a link, SwiftUI adds the corresponding value, such as `Color.mint`, to `path`. SwiftUI uses the [`State`](https://developer.apple.com/documentation/swiftui/state) property called `path` to mange the state of the navigation stack.
[`init(path:root:)`](https://developer.apple.com/documentation/swiftui/navigationstack/init\(path:root:\)) also provides an initializer in which the path parameter takes a [`Binding`](https://developer.apple.com/documentation/swiftui/binding) to a `RandomAccessCollection` and a `RangeReplaceableCollection` argument. You can store the path as a property in an object that leverages the [`Observable`](https://developer.apple.com/documentation/Observation/Observable\(\)) macro data type, and use property observers such as `willSet` and `didSet` or the [`onChange(of:initial:_:)`](https://developer.apple.com/documentation/swiftui/view/onchange\(of:initial:_:\)) modifier to respond to changes when the value-destination link triggers.
In this case, the navigation path is a homogenous collection type that accepts a standard type, such as `Array`, or a custom data type as shown below:
```
@Observable
class NavigationManager {
    var path: [Color] = [] {
        willSet {
            print("will set to \(newValue)")
        }
        
        didSet {
            print("didSet to \(path)")
        }
    }
}


struct ContentView: View {
    @State private var navigationManager = NavigationManager()


    var body: some View {
        NavigationStack(path: $navigationManager.path) {
            List {
                NavigationLink("Mint", value: Color.mint)
                NavigationLink("Red", value: Color.red)
            }
            .navigationDestination(for: Color.self) { color in
                ColorDetail(color: color, text: color.description)
            }
        }
    }
}

```

In the example above, the `willSet` and `didSet` property observers track when a navigation link triggers.
You can also use the reference to `path` variable to perform programmatic navigation. For example, you can pop a view off the stack:
```
@Observable
class NavigationManager {
    var path: [Color] = [] {
        willSet {
            print("will set to \(newValue)")
        }
        
        didSet {
            print("didSet to \(path)")
        }
    }
    
    @discardableResult
    func navigateBack() -> Color? {
        path.popLast()
    }
}

```

Use a standard type when your stack displays views that rely on a single type of data, and `NavigationPath` when you need to present multiple data types in a single stack, as in the following example:
```
struct ValueView: View {
    @State private var path = NavigationPath()
    
    var body: some View {
        NavigationStack(path: $path) {
            List {
                NavigationLink("Mint", value: Color.mint)
                NavigationLink("Red", value: Color.red)
                NavigationLink("Apple Pie", value: Recipe.applePie)
                NavigationLink("Chocolate Cake", value: Recipe.chocolateCake)
            }
            .navigationDestination(for: Color.self) { color in
                ColorDetail(color: color)
            }
            .navigationDestination(for: Recipe.self) { recipe in
                RecipeDetailView(recipe: recipe)
            }
        }
    }
}

```

Note
Both value- and view-destination links ultimately push a user-visible view onto the stack. However, pushed value-destinations are reflected in the stack’s `path` `Binding` (if provided), while pushed view-destinations aren’t.
When composed together, the navigation APIs allow you to use both styles of links, depending on what works best.
Here, when someone taps on the link “View Mint Color”, SwiftUI pushes the value-based destination link onto the stack, followed by a view-destination link:
```
struct ContentView: View {
    @State private var navigationManager = NavigationManager()


    var body: some View {
        NavigationStack(path: $navigationManager.path) {
            NavigationLink("View Mint Color", value: Color.mint)
                .navigationDestination(for: Color.self) { color in
                    NavigationLink("Push Recipe View") {
                        RecipeDetailView(recipe: .applePie)
                    }
                }
        }
    }
}

```

After the code in this example runs, and someone clicks each `NavigationLink`, the navigation stack builds up with three views: 

Root
    
The starting view of the `NavigationStack`. 

Collection of values
    
A sequence of zero or more values, such as `Color.mint`, pushed onto the path. The values serve as identifiers or keys that SwiftUI uses to determine which views to present. 

Collection of views
    
A sequence of views such as `RecipeDetailView`, added to the path. This view is enclosed in the navigation destination and displayed when someone taps the link.
SwiftUI keeps track of the entire navigation path. The underlying data structure looks like the following example:
```
Root → [Color.mint] → [RecipeDetailView]

```

Conceptually, SwiftUI stacks view-based destinations on top of the value-based destinations in the stack’s navigation path. For example, the code below replaces `RecipeDetailView` from the above example with a `NavigationLink`:
```
struct ContentView: View {
    @State private var navigationManager = NavigationManager()


    var body: some View {
        NavigationStack(path: $navigationManager.path) {
            NavigationLink("View Mint Color", value: Color.mint)
                .navigationDestination(for: Color.self) { color in
                    NavigationLink("Push Recipe View") {
                        NavigationLink("Push another view", value: Color.pink)
                    }
                }
        }
    }
}

```

When you run the revised example, the view-destination link is still on the top of the stack.
If you use a heterogenous or homogeneous path on the stack, you may observe changes to the navigation path over time, as shown below:
```
@Observable
class NavigationManager {
    var path: [Color] = [] {
        didSet {
            print("didSet to \(path)")
        }
    }
}


struct ContentView: View {
    @State private var navigationManager = NavigationManager()


    var body: some View {
        NavigationStack(path: $navigationManager.path) {
            NavigationLink("View Mint Color", value: Color.mint)
                .navigationDestination(for: Color.self) { color in
                    NavigationLink("Push Recipe View") {
                        RecipeDetailView(recipe: .applePie)
                    }
                }
        }
    }
}

```

When someone navigates through the app, it prints the following logs:
```
New path: []
New Path: [Color.mint]

```

The logs print because view-destination navigation links don’t cause any state changes that your app can observe. If you attempt to push a value while a view-destination link is on the stack, SwiftUI pops all view destinations and pushes the value’s destination onto the stack.
### [Restore state for navigation paths](https://developer.apple.com/documentation/swiftui/understanding-the-composition-of-navigation-stack#Restore-state-for-navigation-paths)
State restoration for a navigation path enables you restore your interface to the previous interaction point during a subsequent launch, providing continuity for people using your app.
In iOS, state restoration is especially important at the window or scene level, because windows come and go frequently. For this reason, it’s important to think about state restoration for navigation path in the same way you handle restoring your app’s state at the window or scene level. See [Restoring your app’s state with SwiftUI](https://developer.apple.com/documentation/swiftui/restoring-your-app-s-state-with-swiftui) to learn about storing scene data.
Using `Codable`, you can manually persist and load the navigation stack path in one of two ways, depending on whether the path data type is homogeneous or heterogeneous. Store a homogenous path as in the following example:
```
@Observable
class NavigationManager {
    var path: [Recipe] = [] {
        didSet {
            save()
        }
    }
    
    /// The URL for the JSON file that stores the navigation path.
    private static var dataURL: URL {
        .documentsDirectory.appending(path: "NavigationPath.json")
    }
    
    init() {
        do {
            // Load the data model from the 'NavigationPath' data file found in the Documents directory.
            let path = try load(url: NavigationManager.dataURL)
            self.path = path
        } catch {
            // Handle error.
        }
    }
    
    func save() {
        let encoder = JSONEncoder()
        do {
            let data = try encoder.encode(path)
            try data.write(to: NavigationManager.dataURL)
        } catch {
            // Handle error.
        }
    }
    
    /// Load the navigation path from a previously saved state.
    func load(url: URL) throws -> [Recipe] {
        let data = try Data(contentsOf: url, options: .mappedIfSafe)
        let decoder = JSONDecoder()
        return try decoder.decode([Recipe].self, from: data)
    }
}


struct ContentView: View {
    @State private var navigationManager = NavigationManager()


    var body: some View {
        NavigationStack(path: $navigationManager.path) {
            List {
                NavigationLink("Mint", value: Color.mint)
                NavigationLink("Red", value: Color.red)
                NavigationLink("Apple Pie", value: Recipe.applePie)
                NavigationLink("Chocolate Cake", value: Recipe.chocolateCake)
            }
            .navigationDestination(for: Color.self) { color in
                ColorDetail(color: color, text: color.description)
            }
            .navigationDestination(for: Recipe.self) { recipe in
                RecipeDetailView(recipe: recipe)
            }
        }
    }
}

```

In the above example, when the `path` changes, `didSet` property observer triggers and the `save` function is called. The function saves the new path to disk enabling the app to restore it when initializing `NavigationManager`.
Store a heterogeneous path using `NavigationPath`, as shown in the following example:
```
@Observable
class NavigationManager {
    var path = NavigationPath() {
        didSet {
            save()
        }
    }
    
    /// The URL for the JSON file that stores the navigation path.
    private static var dataURL: URL {
        .documentsDirectory.appending(path: "NavigationPath.json")
    }
    
    init() {
        do {
            // Load the data model from the 'NavigationPath' data file found in the Documents directory.
            let path = try load(url: NavigationManager.dataURL)
            self.path = path
        } catch {
            // Handle error
        }
    }
    
    func save() {
        guard let codableRepresentation = path.codable else { return }
        let encoder = JSONEncoder()
        do {
            let data = try encoder.encode(codableRepresentation)
            try data.write(to: NavigationManager.dataURL)
        } catch {
            //Handle error.
        }
    }
    
    /// Load the navigation path from a previously saved data.
    func load(url: URL) throws -> NavigationPath {
        let data = try Data(contentsOf: url, options: .mappedIfSafe)
        let decoder = JSONDecoder()
        let path = try decoder.decode(NavigationPath.CodableRepresentation.self, from: data)
        return NavigationPath(path)
    }
}



```

In the example above, the `save` method checks `path.codable` for nullability. This value describes the contents of the path in a serializable format. It returns `nil` if any of the type-erased elements of the path don’t conform to the `codable`.
It’s important to perform this check because `NavigationPath` doesn’t require the data types to conform to `Codable`. `NavigationPath` only needs the types to conform to `Hashable`, and as a result, you can’t verify that the navigation path is a valid representation of `Codable` at compile time.
To learn more about navigation stacks, links and paths, see [Bringing robust navigation structure to your SwiftUI app](https://developer.apple.com/documentation/swiftui/bringing-robust-navigation-structure-to-your-swiftui-app).
Current page is Understanding the navigation stack 
[Apple](https://www.apple.com)
  1. [Developer](https://developer.apple.com/)
  2. [ Documentation ](https://developer.apple.com/documentation/)


###  Platforms 
Toggle Menu 
  * [iOS](https://developer.apple.com/ios/)
  * [iPadOS](https://developer.apple.com/ipados/)
  * [macOS](https://developer.apple.com/macos/)
  * [tvOS](https://developer.apple.com/tvos/)
  * [visionOS](https://developer.apple.com/visionos/)
  * [watchOS](https://developer.apple.com/watchos/)


###  Tools 
Toggle Menu 
  * [Swift](https://developer.apple.com/swift/)
  * [SwiftUI](https://developer.apple.com/swiftui/)
  * [Swift Playground](https://developer.apple.com/swift-playground/)
  * [TestFlight](https://developer.apple.com/testflight/)
  * [Xcode](https://developer.apple.com/xcode/)
  * [Xcode Cloud](https://developer.apple.com/xcode-cloud/)
  * [SF Symbols](https://developer.apple.com/sf-symbols/)


###  Topics & Technologies 
Toggle Menu 
  * [Accessibility](https://developer.apple.com/accessibility/)
  * [Accessories](https://developer.apple.com/accessories/)
  * [App Extension](https://developer.apple.com/app-extensions/)
  * [App Store](https://developer.apple.com/app-store/)
  * [Audio & Video](https://developer.apple.com/audio/)
  * [Augmented Reality](https://developer.apple.com/augmented-reality/)
  * [Design](https://developer.apple.com/design/)
  * [Distribution](https://developer.apple.com/distribute/)
  * [Education](https://developer.apple.com/education/)
  * [Fonts](https://developer.apple.com/fonts/)
  * [Games](https://developer.apple.com/games/)
  * [Health & Fitness](https://developer.apple.com/health-fitness/)
  * [In-App Purchase](https://developer.apple.com/in-app-purchase/)
  * [Localization](https://developer.apple.com/localization/)
  * [Maps & Location](https://developer.apple.com/maps/)
  * [Machine Learning & AI](https://developer.apple.com/machine-learning/)
  * [Open Source](https://opensource.apple.com/)
  * [Security](https://developer.apple.com/security/)
  * [Safari & Web](https://developer.apple.com/safari/)


###  Resources 
Toggle Menu 
  *   * [Documentation](https://developer.apple.com/documentation/)
  * [Tutorials](https://developer.apple.com/learn/)
  * [Downloads](https://developer.apple.com/download/)
  * [Forums](https://developer.apple.com/forums/)
  * [Videos](https://developer.apple.com/videos/)


###  Support 
Toggle Menu 
  * [Support Articles](https://developer.apple.com/support/articles/)
  * [Contact Us](https://developer.apple.com/contact/)
  * [Bug Reporting](https://developer.apple.com/bug-reporting/)
  * [System Status](https://developer.apple.com/system-status/)


###  Account 
Toggle Menu 
  * [Apple Developer](https://developer.apple.com/account/)
  * [App Store Connect](https://appstoreconnect.apple.com/)
  * [Certificates, IDs, & Profiles](https://developer.apple.com/account/ios/certificate/)
  * [Feedback Assistant](https://feedbackassistant.apple.com/)


###  Programs 
Toggle Menu 
  * [Apple Developer Program](https://developer.apple.com/programs/)
  * [Apple Developer Enterprise Program](https://developer.apple.com/programs/enterprise/)
  * [App Store Small Business Program](https://developer.apple.com/app-store/small-business-program/)
  * [MFi Program](https://mfi.apple.com/)
  * [News Partner Program](https://developer.apple.com/programs/news-partner/)
  * [Video Partner Program](https://developer.apple.com/programs/video-partner/)
  * [Security Bounty Program](https://developer.apple.com/security-bounty/)
  * [Security Research Device Program](https://developer.apple.com/programs/security-research-device/)


###  Events 
Toggle Menu 
  * [Meet with Apple](https://developer.apple.com/events/)
  * [Apple Developer Centers](https://developer.apple.com/events/developer-centers/)
  * [App Store Awards](https://developer.apple.com/app-store/app-store-awards/)
  * [Apple Design Awards](https://developer.apple.com/design/awards/)
  * [Apple Developer Academies](https://developer.apple.com/academies/)
  * [WWDC](https://developer.apple.com/wwdc/)


To submit feedback on documentation, visit [Feedback Assistant](applefeedback://new?form_identifier=developertools.fba&answers%5B%3Aarea%5D=seedADC%3Adevpubs&answers%5B%3Adoc_type_req%5D=Technology%20Documentation&answers%5B%3Adocumentation_link_req%5D=https%3A%2F%2Fdeveloper.apple.com%2Fdocumentation%2Fswiftui%2Funderstanding-the-composition-of-navigation-stack).
Select a color scheme preference
Light
Dark
Auto
Copyright © 2025 [Apple Inc.](https://www.apple.com) All rights reserved. 
[ Terms of Use ](https://www.apple.com/legal/internet-services/terms/site.html)[ Privacy Policy ](https://www.apple.com/legal/privacy/)[ Agreements and Guidelines ](https://developer.apple.com/support/terms/)
